# Цель работы: Научиться использовать быстрые методы поиска минимума.
# Дан набор данных о параметрах школьников разных школ (см. предыдущую работу)
# Теория.
# Для решения задачи нахождения минимума существуют специальные функции в математических библиотеках. Одна из таких библиотек - scipy – библиотека для научных расчётов. Функция нахождения минимума в ней называется
# optimize.minimize(...)
# Данная функция принимает на вход функцию, для которой необходимо найти минимум и ряд аргументов, задающих метод и его параметры, а возвращает структуру с результатами своей работы: собственно аргументы, при которых функция принимает минимальное значение, само значение, статус (успешно/неуспешно), количество итераций алгоритма, и другие.
# Для понимания как использовать функцию minimize необходимо понимать устройство функций в python. Функции являются также объектами и их можно передавать как и другие переменные на вход функции, например:
# def pow2(x): # Функция возводит число в квадрат
# 	return x * x
# def g(f): # Функция получает в качестве аргумента функцию и вызывает её с аргументом 2
# 	return (f(2))
# print g(pow2) # Результат: 4
# В функции minimize некоторые аргументы являются функциями, которые minimize вызывает с разными параметрами при нахождении минимума. Например, сама искомая функция, для которой находится минимум.
# Аргументы функции minimize:
# Функция, для которой находится минимум. Она должна принимать ровно один аргумент. В случае, если это функция нескольких переменных, они должны быть представлены массивом значений.
# Начальное значение (или массив значений) – начальная догадка о минимуме, которая потом уточняется в процессе работы.
# Именные аргументы:
# 	method  – название алгоритма, с помощью которых находится минимум (в нашем случае используется метод “BFGS”
# 	jac – оператор Якоби, функция, которая рассчитывает производную искомой функции. Она также принимает значение или массив значений и возвращает производную (или массив производных в случае функции нескольких переменных). Если не указывать, производные рассчитываются численным методом, что обычно намного дольше.
# 	callback – функция обратного вызова. Она также принимает значение функции или массив значений, она не используется в процессе поиска минимума, но вызывается на каждой итерации алгоритма. Она может, например, выводить в консоль значение функции на текущей итерации.
# Возвращаемое значение - структура с параметрами:
# 	.x – аргумент, при котором функция минимальна
# 	.fun – значение минимума функции
# 	.success – показатель успеха функции(True/False)
# 	.message – сообщение об результатах
# 	.nit – количество итераций алгоритма
# Пример:
# import numpy as np
# from scipy.optimize input minimize
# from itertools import count # Бесконечный счётчик
# def f(x, y): # Исходная функция
# 	return (x-3)**2 + (2 * y-2)**2
# def df(x, y): # Производная функция
# 	return np.array([2*(x-3), 2 * (2*y-2) * 2])
# # Для нахождения минимума исходные аргументы должны быть вектором
# # переменных,поэтому необходимо создать функции-обёртки
# def f_w(x):
# 	return f(x[0], x[1])
# def df_w(x):
# 	return df(x[0], x[1])
# x = [0,0] # Пусть начальная догадка будет [0,0]
# с = Count() # Создаём новый бесконечный счётчик
# def Callback(x): # Функция обратного вызова считает итерации
# 	print(next(c)) # Выводим очередное значение счётчика
# res = scipy.optimize.minimize(f_w, x, method='BFGS', jac=df_w, callback=Callback)
# print(res.x)
# Задача. Составить скрипт, выполняющий линейную регрессию по всем параметрам школьника и определяющий предполагаемую оценку на экзамене в зависимости от параметра. Использовать функцию нахождения минимума из пакета scipy.
# Задание:
# Взять код из предыдущей работы.
# 1. Подготовить функцию стоимости так, чтобы на вход подавался вектор параметров theta (theta должен быть одномерным массивом: theta.shape == (m,) )
# def J(theta):
# 	return value; # value: стоимость при заданных theta
# Примечание: В python можно создавать функции внутри функций, при этом во внутренней функции будут видны переменные внешней функции, например массивы X и y.
# Пример:
# def g(x,y,z): # Функция трёх аргументов
# 	return x + y + z
# def f(x, y):
# 	def g1(z): # Функция одного аргумента, x и y из внешней функции
# 		return g(x, y, z)
# 2. Подготовить функцию производных так, чтобы на вход подавался вектор параметров theta, а функция возвращала вектор производных.
# Примечание: Вектор производных должен быть одномерным массивом.
# def dJ(theta):
# 	return [dJ/dtheta0, dJ/dtheta1, ..., dJ/dthetam]
# 3. Создать функцию отклика такую, что на вход подаётся вектор параметров theta, а функция сохраняла значения theta и стоимости в список (как в предыдущей работе) и печатала информацию согласно номеру варианта  j % 4+ 1:
# 	1. номер итерации
# 	2. функцию стоимости на текущей итерации
# 	3. вектор производных текущей итерации
# 	4. среднее значение производных текущей итерации
# def Callback(theta):
# 	# Добавить значения в массивы
# 	print(...)
# 4. Заменить функцию, считающую градиентный спуск на функцию быстрого нахождения минимума.
